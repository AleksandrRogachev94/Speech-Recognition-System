/*...........................................................................................................

// Функции для комплексных чисел.
polar,conj,real,imag,abs,arg,sqrt,pow,exp,log,

// Класс комплексных чисел.
class complex { complex,complex,
'+c','-c','c+c','c-c','c*c','c/c','c*d','d*c','c/d','d/c','+=c','-=c','*=c','/=c','=d','*=d','/=d'}

...........................................................................................................*/

#include "stdafx.h"

#include <math.h>
#include "cmplx.h"

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Макросы и определения.

#define SmCnst32_d 1.e-32

#define SQRT(v) (v<SmCnst32_d?0.:sqrt(v)) // Нахождение квадратного корня.

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// Функции для комплексных чисел.

//-----------------------------------------------------------------------------------------------------------
// Создание комплексного числа по амплитуде и фазе.

complex polar(double Abs,double Phase)
{
complex c;

c.re=Abs*cos(Phase); c.im=Abs*sin(Phase); return c;
}

//-----------------------------------------------------------------------------------------------------------
// Комплексное сопряжение.

complex conj(complex c)
{
return complex(c.re,-c.im);
}

//-----------------------------------------------------------------------------------------------------------
// Действительная часть.

double real(complex c)
{
return c.re;
}

//-----------------------------------------------------------------------------------------------------------
// Мнимая часть.

double imag(complex c)
{
return c.im;
}

//-----------------------------------------------------------------------------------------------------------
// Модуль комплексного числа.

double abs(complex c)
{
double v;

v=pow(c.re,2.)+pow(c.im,2.); return SQRT(v);
}

//-----------------------------------------------------------------------------------------------------------
// Аргумент комплексного числа.

double arg(complex c)
{
return atan2(c.im,c.re);
}

//-----------------------------------------------------------------------------------------------------------
// Квадратный корень.

complex sqrt(complex c)
{
double Abs,Arg;

Abs=abs(c); Arg=arg(c); return polar(SQRT(Abs),Arg*0.5);
}

//-----------------------------------------------------------------------------------------------------------
// Возведение в степень.

complex pow(complex c,double p)
{
double Abs,Arg;

Abs=abs(c); Arg=arg(c); return polar(pow(Abs,p),Arg*p);
}

//-----------------------------------------------------------------------------------------------------------
// Экспонента.

complex exp(complex c)
{
return polar(exp(c.re),c.im);
}

//-----------------------------------------------------------------------------------------------------------
// Логарифм.

complex log(complex c)
{
return polar(log(abs(c)),arg(c));
}

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// Класс комплексных чисел.

//-----------------------------------------------------------------------------------------------------------
// Конструктор.

complex::complex()
{
}

//-----------------------------------------------------------------------------------------------------------
// Конструктор.

complex::complex(double re_,double im_)
{
re=re_; im=im_;
}

//-----------------------------------------------------------------------------------------------------------
// Знак плюс.

complex complex::operator +()
{
return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Знак минус.

complex complex::operator -()
{
return complex(-re,-im);
}

//-----------------------------------------------------------------------------------------------------------
// Сложение.

complex operator +(complex &a,complex &b)
{
return complex(a.re+b.re,a.im+b.im);
}

//-----------------------------------------------------------------------------------------------------------
// Вычитание.

complex operator -(complex &a,complex &b)
{
return complex(a.re-b.re,a.im-b.im);
}

//-----------------------------------------------------------------------------------------------------------
// Умножение.

complex operator *(complex &a,complex &b)
{
return complex(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);
}

//-----------------------------------------------------------------------------------------------------------
// Деление.

complex operator /(complex &a,complex &b)
{
double v,R,I;

v=1./(b.re*b.re+b.im*b.im); R=a.re*v; I=a.im*v; return complex(R*b.re+I*b.im,I*b.re-R*b.im);
}

//---------------------------------------------------------------------------------------------------------------------------
// Умножение на число.

complex operator *(complex &a,double d)
{
complex c;

c.re=a.re*d; c.im=a.im*d; return c;
}

//---------------------------------------------------------------------------------------------------------------------------
// Умножение на число.

complex operator *(double d,complex &a)
{
complex c;

c.re=a.re*d; c.im=a.im*d; return c;
}

//---------------------------------------------------------------------------------------------------------------------------
// Деление на число.

complex operator /(complex &a,double d)
{
complex c;

c.re=a.re/d; c.im=a.im/d; return c;
}

//---------------------------------------------------------------------------------------------------------------------------
// Деление на число.

complex operator /(double d,complex &a)
{
double R;

R=d/(a.re*a.re+a.im*a.im); return complex(R*a.re,-R*a.im);
}

//-----------------------------------------------------------------------------------------------------------
// Прибавление комплексного числа.

complex complex::operator +=(complex &a)
{
re+=a.re; im+=a.im; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Вычитание комплексного числа.

complex complex::operator -=(complex &a)
{
re-=a.re; im-=a.im; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Умножение на комплексное число.

complex complex::operator *=(complex &a)
{
complex c;

c.re=re; c.im=im; c=c*a; re=c.re; im=c.im; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Деление на комплексное число.

complex complex::operator /=(complex &a)
{
complex c;

c.re=re; c.im=im; c=c/a; re=c.re; im=c.im; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Присваивание действительного числа.

complex complex::operator =(double d)
{
re=d; im=0.; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Умножение на число.

complex complex::operator *=(double d)
{
re*=d; im*=d; return *this;
}

//-----------------------------------------------------------------------------------------------------------
// Деление на число.

complex complex::operator /=(double d)
{
re/=d; im/=d; return *this;
}
